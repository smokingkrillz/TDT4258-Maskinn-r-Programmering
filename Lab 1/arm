// palinfinder.s, provided with Lab1 in TDT4258 autumn 2025
.global _start

// ===== Memory-mapped I/O (DE1-SoC on cpulator) =====
// LEDR base (32-bit)
.equ LEDR_BASE,       0xFF200000
// JTAG UART: data at +0x0, control at +0x4 (WSPACE in [31:16])
.equ JTAG_UART_BASE,  0xFF201000
.equ JTAG_UART_DATA,  0xFF201000
.equ JTAG_UART_CTRL,  0xFF201004

// ====== Messages to print over UART ======
.data
.align
pal_msg:      .asciz "Palindrom detected\n"
notpal_msg:   .asciz "Not a palindrom\n"


input:        .asciz "Grav ned den varg"

.text


_start:
    // r0 := &input
    ldr     r0, =input
    // call checker; returns r0 = 1 if palindrome, 0 otherwise
    bl      check_palindrom
    cmp     r0, #0
    beq     is_no_palindrom
    b       is_palindrom


// -------------------------------------------------------------
// check_input:
// (Optional hook in your skeleton. We compute length inline
// in the palindrome function, so this label is unused here.)
// -------------------------------------------------------------
check_input:
    bx      lr


// -------------------------------------------------------------
// check_palindrom
//  in : r0 = pointer to C-string (null-terminated)
// out : r0 = 1 if palindrome under rules, else 0
// -------------------------------------------------------------
check_palindrom:
// push means save registers on stack, lr = link register (return address)
    push    {r4-r7, lr}

    // r4 = left pointer, r5 = right pointer
    //mov means copy
    // r4 = &str[0], its empty now

    mov     r4, r0          // left = &str[0]
    mov     r5, r0          // find end -> r5

// find_end: advance r5 until null, then step back to last char
// what is happening? we are finding the end of the string

1:  ldrb    r1, [r5]        // r1 = *r5
    cmp     r1, #0
    beq     2f
    add     r5, r5, #1
    b       1b
2:  subs    r5, r5, #1      // r5 now at last valid char (before '\0') ( it has the last character of the string)

    // Main loop: compare pairs while left < right
3:  // Skip spaces on the left
    ldrb    r1, [r4]        // r1 = *left
    cmp     r1, #' '        // ASCII 32
    bne     4f
    add     r4, r4, #1
    b       3b

4:  // Skip spaces on the right
    ldrb    r2, [r5]        // r2 = *right
    cmp     r2, #' '
    bne     5f
    subs    r5, r5, #1
    b       3b

5:  // If left >= right, weâ€™re done (palindrome)
    cmp     r4, r5
    bhs     9f              // >= : success

    // Manual lowercase: if 'A'..'Z' add 32
    // Left char in r1
    mov     r3, r1
    cmp     r3, #'A'
    blt     6f
    cmp     r3, #'Z'
    bgt     6f
    add     r1, r1, #32     // tolower
6:
    // Right char in r2
    mov     r3, r2
    cmp     r3, #'A'
    blt     7f
    cmp     r3, #'Z'
    bgt     7f
    add     r2, r2, #32     // tolower
7:
    // If equal, advance both
    cmp     r1, r2
    beq     8f

    // Wildcards: '?' or '#'
    cmp     r1, #'?'
    beq     8f
    cmp     r1, #'#'
    beq     8f
    cmp     r2, #'?'
    beq     8f
    cmp     r2, #'#'
    beq     8f

    // Mismatch without wildcards -> not palindrome
    mov     r0, #0
    b       10f

8:  // advance inward and continue
    add     r4, r4, #1
    subs    r5, r5, #1
    b       3b

9:  // success
    mov     r0, #1

10: pop     {r4-r7, pc}


// -------------------------------------------------------------
// is_palindrom:
// - Switch on only the 5 rightmost LEDs (bits 0..4 = 1 -> 0x1F)
// - Write "Palindrom detected" to UART
// -------------------------------------------------------------
is_palindrom:
    // LED = 0x0000001F
    ldr     r1, =LEDR_BASE
    mov     r0, #0x1F
    str     r0, [r1]

    // UART print pal_msg
    ldr     r0, =pal_msg
    bl      puts_uart
    b       _exit


// -------------------------------------------------------------
// is_no_palindrom:
// - Switch on only the 5 leftmost LEDs (bits 9..5 -> 0x3E0)
// - Write "Not a palindrom" to UART
// -------------------------------------------------------------
is_no_palindrom:
    // LED = 0x000003E0
    ldr     r1, =LEDR_BASE
    mov     r0, #0x3E0
    str     r0, [r1]

    // UART print notpal_msg
    ldr     r0, =notpal_msg
    bl      puts_uart
    b       _exit


// -------------------------------------------------------------
// UART helpers (JTAG UART)
//   puts_uart(r0=ptr) -> prints a null-terminated string
//   putc_uart(r0=char) -> prints one character (polls WSPACE)
// -------------------------------------------------------------
puts_uart:
    // r0 = pointer to C-string
    push    {r4, lr}
    mov     r4, r0
11:
    ldrb    r0, [r4]        // load next char
    cmp     r0, #0
    beq     12f
    bl      putc_uart
    add     r4, r4, #1
    b       11b
12:
    pop     {r4, pc}

putc_uart:
    // Wait until WSPACE (ctrl[31:16]) > 0, then write byte to data
13:
    ldr     r1, =JTAG_UART_CTRL
    ldr     r2, [r1]        // ctrl
    mov     r2, r2, lsr #16 // r2 = WSPACE
    cmp     r2, #0
    beq     13b
    // Write the character
    ldr     r1, =JTAG_UART_DATA
    str     r0, [r1]
    bx      lr


_exit:
 
    b       .
